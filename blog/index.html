<!DOCTYPE html>
<html prefix="        og: http://ogp.me/ns# article: http://ogp.me/ns/article#     " vocab="http://ogp.me/ns" lang="es">
<head>
<meta charset="utf-8">
<meta name="description" content="Sitio Academico de Tomas Delvechio">
<meta name="viewport" content="width=device-width">
<title>Tomás Delvechio</title>
<link href="../assets/css/all.css" rel="stylesheet" type="text/css">
<meta name="theme-color" content="#5670d4">
<meta name="generator" content="Nikola (getnikola.com)">
<link rel="alternate" type="application/rss+xml" title="RSS" hreflang="es" href="../rss.xml">
<link rel="canonical" href="http://tomasdelvechio.github.io/blog/">
<!--[if lt IE 9]><script src="../assets/js/html5shiv-printshiv.min.js"></script><![endif]-->
</head>
<body>
    <!-- FIXME: reenable <a href="#content" class="sr-only sr-only-focusable">Ir al contenido principal</a> -->
    <section class="section"><div class="container">
            
    <nav id="nav-main" class="nav"><div id="nav-name" class="nav-left">
        
<a id="nav-anchor" class="nav-item" href="../" title="Tomás Delvechio" rel="home">
    <h1 id="nav-heading" class="title is-4">
        <span id="blog-title">Tomás Delvechio</span>
    </h1>
</a>

      </div>
      <div class="nav-right">
        <nav id="nav-items" class="nav-item level is-mobile"><a class="level-item" href="../blog">Blog</a>
            <a class="level-item" href="../old">Old Blog</a>
            <a class="level-item" href="../rss.xml">RSS</a>

    

    
    
    </nav>
</div>
    </nav>
</div>
    </section><section class="section"><div class="container">
            

    


    

    <article><h2 class="subtitle is-6 date">2020-07-12 16:59</h2>
        <h1 class="title"><a href="screencasts-en-gnome-3/">Screencasts en Gnome 3</a></h1>
        <div class="content">
                <div>
<p>Estoy preparando una charla que voy a dar en un par de semanas. Como material de la misma voy a integrar algunos videos de ejemplos, para no tener que ejecutarlos en vivo (porque a veces pueden fallar, roba tiempo de la charla, que la idea es que sea fluida, etc...)</p>
<p>Cuestión que, al no estar subido a la moda de ser Youtuber ni Streamer ni similar, no manejo el set de software estándar (Si, ya se, OBS + algún que otro editor onda Kdenlive). Esta bueno eso, pero a veces puede sonar a demasiado.</p>
<p>Soy usuario de Ubuntu + Gnome 3 desde hace años, y en algún momento me había cruzado con un atajo de teclado para activar una grabación del escritorio. Lo olvidé, pero en Reddit <a href="https://www.reddit.com/r/gnome/comments/hpxzfg/til_you_can_use_shiftctrlaltr_to_record_a_video/">hoy me volvi a cruzar con eso</a>, y recordé lo simple que era para evitar OBS (que de nuevo, esta muy bien, pero puede ser demasiado).</p>
<p>Lo estuve probando, y si bien no se si es lo que voy a usar definitivo, si esta bueno tener "a mano", saber que existe y como usarlo.</p>
<h3>Screencast en Gnome 3</h3>
<p>Antes yo lo conocía como Screencast, hoy son Vlogs o directamente un canal de Youtube. La idea es clips de videos que muestren como hacer algo "técnico", una solución a algo o documentar la forma de arreglar un problema.</p>
<p>Gnome 3 tiene la funcionalidad nativa de hacer Screencast casi <a href="https://help.gnome.org/users/gnome-help/stable/screen-shot-record.html#screencast">desde que salió</a>.</p>
<p>Para activarla, basta ejecutar <code>Ctrl</code> + <code>Alt</code> + <code>Shift</code> + <code>R</code>. Eso hace que en el panel de arriba a la derecha aparezca un icono "rojo".</p>
<blockquote class="imgur-embed-pub" lang="en" data-id="yf5BVor" data-context="false"><a href="//imgur.com/yf5BVor">TIL you can use Shift+Ctrl+Alt+R to record a video of the screen.</a></blockquote>

<script async src="//s.imgur.com/min/embed.js" charset="utf-8"></script><p>source: <a href="https://imgur.com/yf5BVor">https://imgur.com/yf5BVor</a></p>
<p>Ellos dicen que lo integraron por propósitos de depuración. Con lo cual, las configuraciones por defecto son bastante pobres. Por ejemplo, el máximo de grabación por defecto son 30 segundos.</p>
<p>Como todo desde que encararon esa filosofía del nuevo escritorio, lo dejaron ahí, muy poco documentado, y se olvidaron. No se si se olvidaron, pero cuando un usuario les pide que le agreguen "opciones" la respuesta es "esta ahí, que alguien haga una extensión". Que se yo, cada uno maneja sus comunidades como quiere, y a Gnome la verdad que le va bastante bien. Pero es una respuesta medio chocante para mi.</p>
<h3>EasyScreenCast</h3>
<p>En fin, cuestión que alguien si le hizo caso al comentario y por eso existe la extensión <a href="https://extensions.gnome.org/extension/690/easyscreencast/">EasyScreenCast</a>. La use un rato, anda joya, y tiene muchas opciones para configurar.</p>
<p><img alt="" src="https://extensions.gnome.org/extension-data/screenshots/screenshot_690_GFOsR6g.png"></p>
<p>En particular tuve unos problemas a la hora de grabar algo que no sea todo el escritorio (tengo dos monitores entonces es incomodo para usarlo). Pero rompía el escritorio (era necesario reiniciarlo) así que por el momento, no se si es lo que voy a usar. Capaz me pongo a hacer debug, pero por ahora es algo que tira para atrás el uso. Mi hipótesis es que al tener un Ubuntu viejo (18.04) la versión de Gnome con el plugin no están congeniando del todo bien.</p>
<p>En caso de encontrarle la vuelta, actualizo el post.</p>
</div>
        </div>
    </article><article><div class="subtitle tags is-6 is-pulled-right">
                <a class="subtitle is-6" href="../categories/disk-usage/">#disk usage</a>
                |
                <a class="subtitle is-6" href="../categories/free-space/">#free space</a>
        </div>
        <h2 class="subtitle is-6 date">2020-07-03 18:45</h2>
        <h1 class="title"><a href="borrando-cosas-inutiles-de-ubuntu-version-2020/">Borrando Cosas Inutiles de Ubuntu (Versión 2020)</a></h1>
        <div class="content">
                <div>
<h3>Introducción</h3>
<p>Nunca esta demás saber que cosas borrar para mantener el disco raíz lo mas libre posible. Hoy me encontré con el Disco raíz con un 86% de ocupación y me dispuse a buscar cosas para borrar.</p>
<pre class="code literal-block"><span></span><code>$ df -h 
Filesystem      Size  Used Avail Use% Mounted on
...
/dev/sda1        38G   31G  <span class="m">5</span>,0G  <span class="m">86</span>% /
...
</code></pre>


<h3>Herramienta de diagnostico</h3>
<p>Ok, que hacer? En primer lugar, un diagnostico. La primer mano nos la puede dar la aplicación <code>baobab</code>, que si mal no recuerdo siempre esta instalada (si tenes el escritorio por defecto de Ubuntu).</p>
<p>Se busca desde el launcher con ese nombre o "Analizador de Uso de Disco". Muestra las diferentes particiones y gráficos de forma cómoda directorios y sub-directorios:</p>
<p><img alt="Baobab Screenshoot" src="../img/blog/2020/baobab-screenshot.png"></p>
<h3>Replicas de paquetes de Snap</h3>
<p>Ya usando <code>baobab</code> investigo y encuentro que uno de los directorios que mas archivo tiene es <code>/var/lib/snapd/snaps</code>. Ahi me encuentro con lo siguiente:</p>
<pre class="code literal-block"><span></span><code>$ ls -la /var/lib/snapd/snaps
total <span class="m">6180056</span>
drwxr-xr-x  <span class="m">3</span> root root      <span class="m">4096</span> jul  <span class="m">3</span> <span class="m">18</span>:40 .
drwxr-xr-x <span class="m">21</span> root root      <span class="m">4096</span> jul  <span class="m">3</span> <span class="m">18</span>:55 ..
-rw-------  <span class="m">2</span> root root  <span class="m">57266176</span> jun <span class="m">13</span> <span class="m">12</span>:12 bitwarden_25.snap
-rw-------  <span class="m">1</span> root root  <span class="m">57257984</span> jun <span class="m">29</span> <span class="m">21</span>:35 bitwarden_26.snap
-rw-------  <span class="m">1</span> root root  <span class="m">57614336</span> mar <span class="m">25</span> <span class="m">22</span>:43 core18_1705.snap
-rw-------  <span class="m">1</span> root root  <span class="m">57618432</span> abr <span class="m">30</span> <span class="m">14</span>:28 core18_1754.snap
-rw-------  <span class="m">2</span> root root  <span class="m">63942656</span> jun <span class="m">19</span> <span class="m">11</span>:05 core20_634.snap
-rw-------  <span class="m">1</span> root root <span class="m">101724160</span> jun  <span class="m">2</span> <span class="m">16</span>:18 core_9289.snap
-rw-------  <span class="m">1</span> root root <span class="m">101191680</span> jun <span class="m">24</span> <span class="m">16</span>:07 core_9436.snap
-rw-------  <span class="m">2</span> root root  <span class="m">61710336</span> feb <span class="m">27</span> <span class="m">02</span>:55 discord_108.snap
-rw-------  <span class="m">1</span> root root  <span class="m">60096512</span> mar <span class="m">18</span> <span class="m">11</span>:54 discord_109.snap
-rw-------  <span class="m">1</span> root root  <span class="m">93212672</span> jun <span class="m">23</span> <span class="m">16</span>:27 drawio_37.snap
-rw-------  <span class="m">1</span> root root  <span class="m">93224960</span> jun <span class="m">28</span> <span class="m">21</span>:35 drawio_38.snap
-rw-------  <span class="m">2</span> root root <span class="m">193806336</span> may <span class="m">14</span>  <span class="m">2019</span> eclipse_40.snap
-rw-------  <span class="m">1</span> root root <span class="m">220319744</span> mar <span class="m">25</span> <span class="m">07</span>:39 eclipse_48.snap
-rw-------  <span class="m">1</span> root root <span class="m">208605184</span> mar <span class="m">11</span> <span class="m">20</span>:01 gitkraken_153.snap
-rw-------  <span class="m">1</span> root root <span class="m">208609280</span> abr <span class="m">22</span> <span class="m">20</span>:45 gitkraken_154.snap
-rw-------  <span class="m">1</span> root root <span class="m">147488768</span> may <span class="m">30</span> <span class="m">12</span>:22 gnome-3-26-1604_100.snap
-rw-------  <span class="m">1</span> root root <span class="m">147501056</span> nov <span class="m">17</span>  <span class="m">2019</span> gnome-3-26-1604_98.snap
</code></pre>


<p>Las apps están descargadas y "backupeadas" por las dudas.</p>
<p><a href="https://snapcraft.io/">Snap</a> es una manera de instalar apps en Linux, fuertemente impulsada por Canonical. A veces es cómoda para instalar apps que no están en los repos clásicos o están en una versión desactualizada (via Apt).</p>
<p>Buscando un poco, se llega al siguiente comando:</p>
<pre class="code literal-block"><span></span><code>$ snap list --all
Name                     Version                     Rev   Tracking          Publisher         Notes                                                           
bitwarden                <span class="m">1</span>.18.0                      <span class="m">25</span>    latest/stable     bitwarden✓        disabled                                                        
bitwarden                <span class="m">1</span>.19.0                      <span class="m">26</span>    latest/stable     bitwarden✓        -                                                               
core                     <span class="m">16</span>-2.45.1                   <span class="m">9436</span>  latest/stable     canonical✓        core                                                            
core                     <span class="m">16</span>-2.45                     <span class="m">9289</span>  latest/stable     canonical✓        core,disabled                                                   
core18                   <span class="m">20200311</span>                    <span class="m">1705</span>  latest/stable     canonical✓        base,disabled                                                   
core18                   <span class="m">20200427</span>                    <span class="m">1754</span>  latest/stable     canonical✓        base                                                            
core20                   <span class="m">20</span>                          <span class="m">634</span>   latest/stable     canonical✓        base                                                            
discord                  <span class="m">0</span>.0.10                      <span class="m">108</span>   latest/stable     snapcrafters      disabled                                                        
discord                  <span class="m">0</span>.0.10                      <span class="m">109</span>   latest/stable     snapcrafters      -                                                               
drawio                   <span class="m">13</span>.3.1                      <span class="m">37</span>    latest/stable     jgraph✓           disabled                                                        
drawio                   <span class="m">13</span>.3.5                      <span class="m">38</span>    latest/stable     jgraph✓           -                                                               
eclipse                  <span class="m">2019</span>-03                     <span class="m">40</span>    latest/stable     snapcrafters      disabled,classic
eclipse                  <span class="m">2019</span>-12                     <span class="m">48</span>    latest/stable     snapcrafters      classic
gitkraken                <span class="m">6</span>.6.0                       <span class="m">154</span>   latest/stable     gitkraken✓        -
gitkraken                <span class="m">6</span>.5.4                       <span class="m">153</span>   latest/stable     gitkraken✓        disabled
</code></pre>


<p>Si en la salida anterior se observa la ultima columna (Notes), se observa que hay muchas versiones en estado <code>disabled</code>. Así que en teoría se pueden borrar. El script que <a href="https://superuser.com/a/1330590/341719">se encuentra aca</a> a mi me funciono joya (ojo que avisan que según el idioma del sistema por ahí lo tienen que tocar).</p>
<p>Dejo una versión del script acá:</p>
<pre class="code literal-block"><span></span><code><span class="ch">#!/bin/bash</span>
<span class="c1"># Removes old revisions of snaps</span>
<span class="c1"># CLOSE ALL SNAPS BEFORE RUNNING THIS</span>
<span class="nb">set</span> -eu

<span class="nv">LANG</span><span class="o">=</span>C snap list --all <span class="p">|</span> awk <span class="s1">'/disabled/{print $1, $3}'</span> <span class="p">|</span>
    <span class="k">while</span> <span class="nb">read</span> snapname revision<span class="p">;</span> <span class="k">do</span>
        sudo snap remove <span class="s2">"</span><span class="nv">$snapname</span><span class="s2">"</span> --revision<span class="o">=</span><span class="s2">"</span><span class="nv">$revision</span><span class="s2">"</span>
    <span class="k">done</span>
</code></pre>


<p>También es una buena idea revisar programas ahí instalados y que no estés usando, y eliminarlos, por ejemplo, en mi caso había un par que no estaba usando y los elimine:</p>
<pre class="code literal-block"><span></span><code>sudo snap remove krita gitkraken eclipse drawio bitwarden youtube-dl
</code></pre>


<p>Para este punto, y solo preocupándome por Snap, la situación estaba así:</p>
<pre class="code literal-block"><span></span><code>$ df -h 
Filesystem      Size  Used Avail Use% Mounted on
...
/dev/sda1        38G   27G  <span class="m">8</span>,5G  <span class="m">77</span>% /
...
</code></pre>


<p>Recupere alrededor de 3.5 Gb.</p>
<h3>Logs is everywhere</h3>
<p>El siguiente directorio que tenia bastante peso era el de logs. 4Gb de logs!!!!!</p>
<pre class="code literal-block"><span></span><code>$ journalctl --disk-usage
Archived and active journals take up <span class="m">3</span>.7G in the file system.
</code></pre>


<p>El directorio principal de logs en un Ubuntu es <code>/var/log</code>, y dentro de dicho directorio, el journal (el log principal del sistema) era el que mas pesaba (casi el total). Ahí veo 2 problemas:</p>
<ul>
<li>Mala política de borrado de logs</li>
<li>Porque se están llenando tanto?</li>
</ul>
<p>Lo segundo es para pensarlo un poco e investigar, para el objetivo del post me voy a centrar en el primero punto.</p>
<h4>Política de borrado</h4>
<p>La rotación de logs es una tarea automática que hace el sistema. Básicamente va creando archivos nuevos para loguear los eventos mas actuales, y deja como históricos los viejos archivos. Para consultar estos registros, se puede usar el comando <code>journalctl</code>. No me voy a detener en este comando que daría para un post entero. Solo decir que una primer configuración a editar es el tamaño del log del sistema. Esto se hace desde <code>/etc/systemd/journald.conf</code>:</p>
<p>Como root, editar ese archivo, cambiando la linea:</p>
<pre class="code literal-block"><span></span><code><span class="c1">#SystemMaxUse=</span>
</code></pre>


<p>por</p>
<pre class="code literal-block"><span></span><code><span class="na">SystemMaxUse</span><span class="o">=</span><span class="s">100M</span>
</code></pre>


<p>Donde el valor después del signo igual, debería ser el tamaño que queremos que ocupe. En este caso,  100 Megas me parece un valor mas que razonable.</p>
<p>Para terminar de aplicar el cambio, hay que reiniciar el servicio:</p>
<pre class="code literal-block"><span></span><code>$ sudo systemctl restart systemd-journald.service
$ journalctl --disk-usage
Archived and active journals take up <span class="m">104</span>.0M in the file system.
</code></pre>


<p>Perfecto. Si volvemos a mirar el espacio en disco:</p>
<pre class="code literal-block"><span></span><code>$ df -h 
Filesystem      Size  Used Avail Use% Mounted on
...
/dev/sda1        38G   24G   13G  <span class="m">66</span>% /
...
</code></pre>


<p>Perfecto. ¿Con que seguir?</p>
<h3>Cache de APT y Librerías sin uso</h3>
<p>APT es la herramienta para gestión de paquetes de Ubuntu. Es típico que en el uso, genere una cache importante, y que en muchos casos queden librerías que ya no se utilizan y pueden borrarse. En mi caso no va a aportar demasiado porque estos comandos los suelo ejecutar con cierta regularidad, pero hay 3 parámetros que son muy útiles y es aconsejable ejecutarlos con cierta regularidad:</p>
<pre class="code literal-block"><span></span><code>$ sudo apt clean
$ sudo apt autoclean
$ sudo apt autoremove
</code></pre>


<p>En el ultimo caso, puede querer eliminar paquetes y nos va a preguntar si estamos seguros. En general, no es problemático eliminarlos (aunque si no se esta seguro, ese ultimo comando podría no ejecutarse).</p>
<pre class="code literal-block"><span></span><code>$ df -h 
Filesystem      Size  Used Avail Use% Mounted on
...
/dev/sda1        38G   23G   13G  <span class="m">65</span>% /
...
</code></pre>


<p>En mi caso no ayudó mucho, pero puede ser útil este paso.</p>
<h3>Directorio /usr</h3>
<p>Si no esta pasando nada raro, y excluyendo el <code>/home</code>, el directorio <code>/usr</code> debería ser uno de los directorios con mas "peso" en el gráfico de <code>Baobab</code>. Es normal y esperable, ya que todas las aplicaciones y librerías del sistema se encuentra allí.</p>
<p>En general no es aconsejable tocar ningún archivo de allí. En caso de tener alguna anomalía, es probable que pueda limpiarse eliminando el paquete o programa que la esta causando, pero no se aconseja eliminar archivos o sub directorios de forma directa en este caso.</p>
<h3>BleachBit</h3>
<p>Para terminar el post, es interesante mencionar esta GUI, llamada <a href="https://www.bleachbit.org/">BleachBit</a>, que es lo mas parecido a CCleaner que tenemos los usuarios de Linux.</p>
<p>Tiene una forma de eliminar cosas del sistema (usar con cuidado) pero al estar centrado en el usuario,  nos haría ganar espacio en el <code>/home</code>. En caso de necesitarlo, es una buena opción.</p>
<p>Luego de borrar algunas cosas, la cantidad de disco ocupada finalmente fue la siguiente:</p>
<pre class="code literal-block"><span></span><code>$ df -h 
Filesystem      Size  Used Avail Use% Mounted on
...
/dev/sda1        38G   23G   13G  <span class="m">64</span>% /
...
</code></pre>


<p>Para mi suficiente, y no me llevo mucho tiempo. Espero que algo de esto les sirva.</p>
</div>
        </div>
    </article><article><div class="subtitle tags is-6 is-pulled-right">
                <a class="subtitle is-6" href="../categories/deploy/">#deploy</a>
                |
                <a class="subtitle is-6" href="../categories/docker/">#docker</a>
                |
                <a class="subtitle is-6" href="../categories/storage/">#storage</a>
        </div>
        <h2 class="subtitle is-6 date">2020-06-22 21:30</h2>
        <h1 class="title"><a href="volumenes-de-docker-y-discos-usb-externos/">Volumenes de Docker y Discos USB Externos</a></h1>
        <div class="content">
                <div>
<p>Estoy levantando un media server en mi maquina, y aprovecho que hay mucho despliegue usando contenedores Docker.</p>
<h3>El Problema</h3>
<p>Como tengo todo mi contenido multimedia en un disco USB externo, aproveche y le vincule los volumenes al contenedor directamente a los paths del disco.</p>
<p>Entonces, los volumenes quedaban mas o menos como sigue. Uso la notación que pone Ubuntu al montar los discos externos:</p>
<pre class="code literal-block"><span></span><code>/media/tomas/Elements/series:/series
/media/tomas/Elements/peliculas:/peliculas
....
</code></pre>


<p>De lado derecho es el path del directorio en el host. Del lado izquierdo es el directorio dentro del contenedor.</p>
<p>Como esto se hace en un equipo particular, eventualmente se reinicia (o se apaga y prende). Esto me genero 1 gran problema.</p>
<p>El servicio de Docker inicia durante el proceso de boot del equipo. Sin embargo, Ubuntu monta el disco al momento en el que el usuario inicia sesión.</p>
<p>Esto genera que Docker intente buscar los directorios de los volumenes en el Host, y al no encontrarlos, los crea. Este comportamiento se conoce como propagación y esta documentado<a href="https://docs.docker.com/storage/#tips-for-using-bind-mounts-or-volumes">1</a>.</p>
<p>Sin embargo, sucedia que al iniciar sesión, Ubuntu intentaba montar en el directorio <code>/media/tomas/Elements</code>, pero debido a que este ya existia (dado que Docker lo creaba por el mecanismo de propagación), Ubuntu monta el disco en <code>/media/tomas/Elements1</code>.</p>
<p>El efecto de esto es que perdia acceso a los directorios dentro del contenedor.</p>
<h3>La idea de solución</h3>
<p>Buscando ayuda, lo que me sugieren y que es la solución es cambiar el orden del booteo, para que Docker inicie despues del proceso de mount. Esto no es tan facil como puede parecer. Requiere:</p>
<ul>
<li>Buscar la unit del servicio de mount</li>
<li>Buscar la unit de systemd del servicio de Docker</li>
<li>Agregar el servicio de mount como dependencia de Docker</li>
<li>Hacer que el mount del disco se haga al inicio y no al iniciar sesion</li>
<li>Probarlo</li>
</ul>
<p>A esa secuencia de pasos llegue luego de un poco de prueba y error.</p>
<p>A continuación documentaré los pasos que tuve que hacer</p>
<h3>La solución</h3>
<p>Aclaración del setup de mi equipo: Tengo una notebook corriendo Ubuntu 18.04, que ejecuta Systemd para gestionar el proceso de arranque del Sistema Operativo. Desconozco si en otras distros esto puede variar.</p>
<h4>Nombre del servicio de mount en Systemd</h4>
<p>Despues de buscar un rato, descubrí que el servicio que maneja el mount al inicio del sistema se llama <code>udisks2.service</code>. Una forma de ver los servicios en systemd es:</p>
<pre class="code literal-block"><span></span><code>systemctl --type<span class="o">=</span>service
</code></pre>


<h4>Agregar dependencia de este servicio al inicio de Docker</h4>
<p>En este paso, necesitamos que docker no arranque hasta que se termine el proceso <code>udisks2.service</code>.</p>
<p>En mi caso, la configuración de Systemd de Docker esta en <code>/lib/systemd/system/docker.service</code> (que tiene ademas un link simbolico en <code>/etc/systemd/system/multi-user.target.wants/docker.service</code>).</p>
<p>Alli dentro, busque la linea que contiene lo siguiente</p>
<pre class="code literal-block"><span></span><code><span class="na">After</span><span class="o">=</span><span class="s">network-online.target firewalld.service containerd.service</span>
</code></pre>


<p>Y agregue al final de la misma (con separación de un espacio)</p>
<pre class="code literal-block"><span></span><code><span class="na">After</span><span class="o">=</span><span class="s">network-online.target firewalld.service containerd.service udisks2.service</span>
</code></pre>


<p>Luego guarde y cerre el archivo.</p>
<p>Para que systemd tome este cambio, tuve que ejecutar:</p>
<pre class="code literal-block"><span></span><code>sudo systemctl daemon-reload
</code></pre>


<h4>Montar el disco al inicio del sistema y no de la sesión</h4>
<p>A continuación, tuve que configurar para que el disco se monte al inicio del sistema. Para ello, voy tomar el camino de hacerlo via interfaz gráfica y no por consola.</p>
<p>Para ello, usé una app que se busca en Gnome como <code>Disks</code>:</p>
<p><img alt="Disks Gnome App" src="../img/blog/2020/figure1.png" title="Disks Gnome App"></p>
<p>Una vez allí, elegimos el disco en cuestion y entramos a sus "opciones de montaje":</p>
<p><img alt="Select Disk Mount Options" src="../img/blog/2020/Selection_024.png" title="Select Disk Mount Options"></p>
<p>En esta nueva pantalla, se indicaron las siguientes cosas:</p>
<ol>
<li>Que no se use las configuraciones por defecto para la sesión</li>
<li>Que se monte al arranque del sistema</li>
<li>Que se identifique con el UUID (Esta ultima es optativa, pero era la que me pareció que dejaba el nombre mas apropiado al directorio donde se iba a montar)</li>
</ol>
<p><img alt="Mount Options Window" src="../img/blog/2020/Selection_026.png" title="Mount Options Window"></p>
<h4>Cambiar los paths en los volumenes</h4>
<p>Una vez terminado esto, pude cambiar los paths de los volumenes del lado del host, dejandolos como sigue:</p>
<pre class="code literal-block"><span></span><code>/mnt/9A567...0FD/series:/series
/mnt/9A567...0FD/peliculas:/peliculas
....
</code></pre>


<p>Probé reiniciar y todo funciono perfecto.</p>
</div>
        </div>
    </article><article><div class="subtitle tags is-6 is-pulled-right">
                <a class="subtitle is-6" href="../categories/big-data/">#big data</a>
                |
                <a class="subtitle is-6" href="../categories/distributed-systems/">#distributed systems</a>
                |
                <a class="subtitle is-6" href="../categories/programming/">#programming</a>
                |
                <a class="subtitle is-6" href="../categories/spark/">#spark</a>
        </div>
        <h2 class="subtitle is-6 date">2018-09-08 15:15</h2>
        <h1 class="title"><a href="introduccion-a-spark/">Introducción a Spark</a></h1>
        <div class="content">
                <div>
<p>Apache Spark es un framework de procesamiento muy de moda en entornos de procesamiento para Big Data, IoT y Machine Learning.</p>
<h3>Pipeline</h3>
<p>El pipeline de trabajo en spark es conocido como <strong>DAG</strong> (Directed Acyclic Graph) y se basa en armar un grafo de trabajo donde las tareas se sucedan unas a otras segun se establezca.</p>
<p>Ademas, propone que muchas operaciones que en MapReduce involucran operaciones de entrada salida a disco, se hagan en memoria principal, lo que genera un rendimiento mayor comparado con su predecesor.</p>
<h3>Lenguajes</h3>
<p>Spark acepta Java, Scala, Python y R, aunque no todos estan soportados de la misma forma y de manera completa.</p>
<h3>Otras herramientas</h3>
<p>Spark ofrece ademas una consola interactiva para Scala, Python y R con capacidades <strong>REPL</strong> (Read, Evaluate, Print y Loop).</p>
<p>Ademas del core, Spark ofrece algunas librerias para tareas comunes en el ambito de big data: <em>SparkSQL</em>, <em>Spark Streaming</em>, <em>Spark MLlib</em> y <em>Spark GraphX</em>.</p>
<p>Es posible vincular Spark a una Notebook de Jupyter y trabajar desde la interfaz de esta herramienta para hacer pruebas. (TODO: Agregar link a la notebook).</p>
<h3>Arquitectura</h3>
<p>Una aplicación Spark consta de un master, que dependiendo de la plataforma puede ser <em>Spark Master</em> (standalone) <em>Mesos Master</em> (Apache Mesos) o <em>ResourceManager</em> (Apache Hadoop - YARN). Luego un proceso driver que se conoce como SparkContext y por ultimo de los workers.</p>
</div>
        </div>
    </article><article><h2 class="subtitle is-6 date">2018-04-28 16:22</h2>
        <h1 class="title"><a href="automatizando-deploy-con-helm/">Automatizando deploy con Helm</a></h1>
        <div class="content">
                <div>
<h2>Automatizando Deploy con Helm</h2>
<ol>
<li>Tener un cluster kubernetes andando y corriendo (por ejemplo minikube)</li>
</ol>
<pre class="code literal-block"><span></span><code>$ minikube start
</code></pre>


<ol>
<li>Instalar Helm y Tiller</li>
</ol>
<p>Tiller es un servidor in cluster de helm (Se instala en el cluster). Para mas detalle, ver la <a href="https://docs.helm.sh/using_helm/#quickstart">doc oficial</a>.</p>
<pre class="code literal-block"><span></span><code>$ helm init
Creating /home/tomas/.helm
Creating /home/tomas/.helm/repository
Creating /home/tomas/.helm/repository/cache
Creating /home/tomas/.helm/repository/local
Creating /home/tomas/.helm/plugins
Creating /home/tomas/.helm/starters
Creating /home/tomas/.helm/cache/archive
Creating /home/tomas/.helm/repository/repositories.yaml
Adding stable repo with URL: https://kubernetes-charts.storage.googleapis.com
Adding <span class="nb">local</span> repo with URL: http://127.0.0.1:8879/charts
<span class="nv">$HELM_HOME</span> has been configured at /home/tomas/.helm.

Tiller <span class="o">(</span>the Helm server-side component<span class="o">)</span> has been installed into your Kubernetes Cluster.

Please note: by default, Tiller is deployed with an insecure <span class="s1">'allow unauthenticated users'</span> policy.
For more information on securing your installation see: https://docs.helm.sh/using_helm/#securing-your-helm-installation
Happy Helming!
</code></pre>


<ol>
<li>Actualizar Respositorio de Charts</li>
</ol>
<p>Los programas que se instalan via Helm se llaman Charts. Antes de instalar un chart, se debe actualizar la lista de charts disponibles</p>
<pre class="code literal-block"><span></span><code>helm repo update
Hang tight <span class="k">while</span> we grab the latest from your chart repositories...
...Skip <span class="nb">local</span> chart repository
...Successfully got an update from the <span class="s2">"stable"</span> chart repository
Update Complete. ⎈ Happy Helming!⎈
</code></pre>
</div>
        </div>
    </article><article><div class="subtitle tags is-6 is-pulled-right">
                <a class="subtitle is-6" href="../categories/charlas/">#charlas</a>
                |
                <a class="subtitle is-6" href="../categories/git/">#git</a>
                |
                <a class="subtitle is-6" href="../categories/vcs/">#vcs</a>
        </div>
        <h2 class="subtitle is-6 date">2018-04-14 12:09</h2>
        <h1 class="title"><a href="curso-de-git/">Curso de Git</a></h1>
        <div class="content">
                <div>
<p>El sabado 07 de Abril de 2018 estuvimos haciendo un taller de GIT en la UNLu. </p>
<p>Fue una experiencia muy interesante. Esperabamos muy poca gente y sin embargo el aula se lleno durante las 3 horas y media que duró el taller. Para algunos usar Git es algo tan omnipresente, que a veces cometemos el error de creer que <em>es facil</em> o que <em>todos lo usan</em>.</p>
<p>Durante mas de 3 horas, 38 personas con conocimientos muy diverso respecto a computación estuvieron aprendiendo como usar Git, surgieron dudas muy interesantes y creo que todos nos llevamos algo nuevo.</p>
<p>El material que se utilizó esta <a href="https://docs.google.com/presentation/d/1LAns3-PGIOVf2KiMyw1sS4Uy7LaGV-bUPlJDQ22gDrc/edit?usp=sharing">disponible aca</a>.</p>
</div>
        </div>
    </article><article><div class="subtitle tags is-6 is-pulled-right">
                <a class="subtitle is-6" href="../categories/cluster/">#cluster</a>
                |
                <a class="subtitle is-6" href="../categories/containers/">#containers</a>
                |
                <a class="subtitle is-6" href="../categories/deploy/">#deploy</a>
                |
                <a class="subtitle is-6" href="../categories/devops/">#devops</a>
                |
                <a class="subtitle is-6" href="../categories/kompose/">#kompose</a>
                |
                <a class="subtitle is-6" href="../categories/kubernetes/">#kubernetes</a>
                |
                <a class="subtitle is-6" href="../categories/orchestration/">#orchestration</a>
        </div>
        <h2 class="subtitle is-6 date">2018-02-04 16:28</h2>
        <h1 class="title"><a href="kompose-migrar-tus-archivos-docker-compose-a-kubernetes/">Kompose: Migrar tus archivos Docker Compose a Kubernetes</a></h1>
        <div class="content">
                <div>
<p>En un <a href="algunas-notas-sobre-kubernetes">post anterior</a> desplegamos un
cluster de pruebas con contenedores usando <a href="https://kubernetes.io">Kubernetes</a> y
<a href="https://github.com/kubernetes/minikube">Minikube</a>. Este esquema resulta util
cuando lo que se quiere es desplegar y escalar un contenedor.</p>
<p>Sin embargo, muchas aplicaciones Docker comenzaron a orquestarse utilizando mas
de un contenedor para hacer funcionar la misma. Por ejemplo, un contenedor con
un web server, otro para la base de datos relacional, y un tercero para una base
nosql.</p>
<p>Para este tipo de esquemas surgio docker-compose. Permitia de forma sencilla
administrar la configuracion varios contenedores en simultaneo cuya imagen
origen eran diferentes.</p>
<p>Para lograr un comportamiento similar con Kubernetes, existe la herramienta
<a href="http://kompose.io">Kompose</a>. Kompose nos permite tomar el contenido de un
archivo docker-compose.yml y realizar las mismas acciones, pero utilizando
Kubernetes.</p>
<h3>Uso basico</h3>
<p>Como siempre, nos salteamos la parte de instalacion dado que es sencilla y se
encuentra documentada en la <a href="http://kompose.io/installation/">pagina oficial</a>.</p>
<p>Kompose es muy sencilla de utilizar. Puede hacer 2 tareas principales:</p>
<ul>
<li>Tomar un archivo docker-compose.yml y convertirlo a archivos de configuracion
 de Kubernetes.</li>
<li>Ejecutar el archivo docker-compose.yml directamente sin generar nuevos
 archivos.</li>
</ul>
<p>La forma mas sencilla de utilizar es la segunda, dado que contamos con un
proyecto con un archivo docker-compose.yml o en general conocemos ese formato
bastante. Entonces se ejecuta</p>
<pre class="code literal-block"><span></span><code><span class="err">kompose up</span>
</code></pre>


<p>y eso ya levanta con Kubernetes todos los contenedores indicados.</p>
<h3>Troubleshooting</h3>
<pre class="code literal-block"><span></span><code><span class="n">kompose</span> <span class="n">up</span>

<span class="n">WARN</span> <span class="n">Unsupported</span> <span class="n">root</span> <span class="k">level</span> <span class="n">volumes</span> <span class="k">key</span> <span class="o">-</span> <span class="n">ignoring</span> 
<span class="n">WARN</span> <span class="n">Unsupported</span> <span class="n">depends_on</span> <span class="k">key</span> <span class="o">-</span> <span class="n">ignoring</span>        
<span class="n">WARN</span> <span class="n">Volume</span> <span class="n">mount</span> <span class="k">on</span> <span class="n">the</span> <span class="k">host</span> <span class="ss">"."</span> <span class="n">isn</span><span class="err">'</span><span class="n">t</span> <span class="n">supported</span> <span class="o">-</span> <span class="n">ignoring</span> <span class="n">path</span> <span class="k">on</span> <span class="n">the</span> <span class="k">host</span>
</code></pre>
</div>
        </div>
    </article><article><div class="subtitle tags is-6 is-pulled-right">
                <a class="subtitle is-6" href="../categories/dev/">#dev</a>
                |
                <a class="subtitle is-6" href="../categories/programming/">#programming</a>
                |
                <a class="subtitle is-6" href="../categories/sublime/">#sublime</a>
                |
                <a class="subtitle is-6" href="../categories/tools/">#tools</a>
        </div>
        <h2 class="subtitle is-6 date">2018-02-03 12:15</h2>
        <h1 class="title"><a href="configuracion-para-sublime-text-3/">Configuración para Sublime Text 3</a></h1>
        <div class="content">
                <div>
<p><img alt="Logo Sublime Text 3" src="../img/blog/2018/logo-sublime-text-3.png" title="Logo de Sublime Text 3"></p>
<p>Soy usuario activo de Sublime Text 3. Para proyectos pequeños o creacion de
scripts, es el editor con el que me siento mas comodo trabajando.</p>
<p>La configuración default que tiene visual tiene algunos problemas. Lo primero
que hago al instalar Sublime es editar un par de estas configuraciones, y dejo
aca el archivo de configuración tal como lo tengo actualmente</p>
<pre class="code literal-block"><span></span><code><span class="err">{</span>
<span class="err">    "bold_folder_labels": true,</span>
<span class="err">    "caret_style": "phase",</span>
<span class="err">    "draw_white_space": "all",</span>
<span class="err">    "fade_fold_buttons": false,</span>
<span class="err">    "font_face": "Inconsolata",</span>
<span class="err">    "font_size": 12,</span>
<span class="err">    "highlight_line": true,</span>
<span class="err">    "highlight_modified_tabs": true,</span>
<span class="err">    "ignored_packages":</span>
<span class="err">    [</span>
<span class="err">        "Vintage"</span>
<span class="err">    ],</span>
<span class="err">    "line_padding_bottom": 5.5,</span>
<span class="err">    "line_padding_top": 5.5,</span>
<span class="err">    "rulers":</span>
<span class="err">    [</span>
<span class="err">        80,</span>
<span class="err">        120</span>
<span class="err">    ],</span>
<span class="err">    "tab_size": 4,</span>
<span class="err">    "trim_trailing_white_space_on_save": true</span>
<span class="err">}</span>
</code></pre>


<h4>Sobre las fuentes</h4>
<p>La configuración <code>font_face</code> indica la fuente utilizada. Inconsolata no es una
fuente que venga instalada por default. Para instalarla en Ubuntu, por ejemplo:</p>
<pre class="code literal-block"><span></span><code><span class="err">sudo apt install fonts-inconsolata</span>
</code></pre>


<h3>Plugines</h3>
<p>Ademas de la configuración visual, Sublime tiene una amplia cantidad de plugins.</p>
<p>Aca va un listado de los que actualmente estoy utilizando:</p>
<ul>
<li>All Autocomplete</li>
<li>BracketHighlighter</li>
<li>DocBlockr</li>
<li>GitGutter</li>
<li>Laravel Blade Highlighter</li>
<li>PHP Companion</li>
<li>SublimeCodeIntel</li>
<li>SublimeLinter-php</li>
</ul>
<h3>Temas</h3>
<p>Existen muchisimos temas para Sublime. Puntualmente estoy en estos momentos
utilizando <a href="https://github.com/kenwheeler/brogrammer-theme">Brogrammer</a>.</p>
</div>
        </div>
    </article><article><div class="subtitle tags is-6 is-pulled-right">
                <a class="subtitle is-6" href="../categories/cluster/">#cluster</a>
                |
                <a class="subtitle is-6" href="../categories/containers/">#containers</a>
                |
                <a class="subtitle is-6" href="../categories/deploy/">#deploy</a>
                |
                <a class="subtitle is-6" href="../categories/devops/">#devops</a>
                |
                <a class="subtitle is-6" href="../categories/kubernetes/">#kubernetes</a>
                |
                <a class="subtitle is-6" href="../categories/orchestration/">#orchestration</a>
        </div>
        <h2 class="subtitle is-6 date">2018-01-26 00:18</h2>
        <h1 class="title"><a href="algunas-notas-sobre-kubernetes/">Algunas notas sobre Kubernetes</a></h1>
        <div class="content">
                <div>
<p><img alt="Logo Kubernetes" src="../img/blog/2018/logo-kubernetes.png" title="Logo de Kubernetes"></p>
<p>Sistema para orquestación de cluster. Esto no es un tutorial, son notas sueltas
(personales) tomadas del <a href="https://kubernetes.io">tutorial oficial</a>.</p>
<h3>1. Crear un cluster</h3>
<p>Kubernetes coordina un cluster para trabajar como una unica unidad. Para ello,
las apps necesitan ser empaquetadas en forma de containers.</p>
<p>2 Recursos:</p>
<ul>
<li>Master: Coordinación y gestión el cluster</li>
<li>Nodes: Son los workers del cluster (puede ser vm o nodo físico)</li>
</ul>
<p>Cada nodo tiene un Kubelet, un agente que coordina el nodo y maneja la
comunicación con el Master.</p>
<p>Cada nodo debe poder realizar operaciones de containers, usando Docker o rkt
(Debe tenerlo instalado).</p>
<p>Para debug se recomienda utilizar <a href="https://github.com/kubernetes/minikube">Minikube</a>.
Instala un cluster y facilita la configuracion de kubernetes (Instalarlo a mano
era complejo).</p>
<h4>Tutorial interactivo</h4>
<p>Testear la version de minikube</p>
<pre class="code literal-block"><span></span><code><span class="err">minikube version</span>
</code></pre>


<p>Iniciar un cluster usando minikube</p>
<pre class="code literal-block"><span></span><code><span class="err">minikube start</span>
</code></pre>


<p>Linea de comandos de Kubernetes: <code>kubectl</code>.</p>
<p>Version de kubectl (Para verificar que esta instalado):</p>
<pre class="code literal-block"><span></span><code><span class="err">kubectl version</span>
</code></pre>


<p>Ver información de cluster</p>
<pre class="code literal-block"><span></span><code><span class="err">kubectl cluster-info</span>
</code></pre>


<p>Ver nodos del cluster</p>
<pre class="code literal-block"><span></span><code><span class="err">kubectl get nodes</span>
</code></pre>


<h3>2. Crear deploys con kubectl</h3>
<p>Una vez instalado Kubernetes, se deben crear aplicaciones en containers para ser
ejecutadas sobre el cluster. Para esto se definen instruccion que el master
ejecuta sobre los nodos.</p>
<p>Kubernetes Deployment Controller monitoriza las instancias y si se caen, las
regenera nuevamente.</p>
<h4>Tutorial interactivo</h4>
<p>Correr un ejemplo</p>
<pre class="code literal-block"><span></span><code><span class="err">kubectl run kubernetes-bootcamp \</span>
<span class="err">    --image=docker.io/jocatalin/kubernetes-bootcamp:v1 \</span>
<span class="err">    --port=8080</span>
</code></pre>


<p>Ver la app en ejecucion</p>
<pre class="code literal-block"><span></span><code><span class="err">kubectl get deployments</span>
</code></pre>


<p>Generar un entrypoint al cluster (temporal para pruebas)</p>
<pre class="code literal-block"><span></span><code><span class="err">kubectl proxy</span>
</code></pre>


<h3>3. Explorar la App</h3>
<p>Un Pod es un conjunto de containers que ejecutan aplicaciones y sus recursos
asociados.</p>
<p>Los Pods son creados por Kubernetes al realizar el deploy de la app. Se crean
siempre en un nodo.</p>
<p>Operaciones mas usadas de <code>kubectl</code>:</p>
<pre class="code literal-block"><span></span><code><span class="err">kubectl get</span>
<span class="err">kubectl describe</span>
<span class="err">kubectl logs</span>
<span class="err">kubectl exec</span>
</code></pre>


<h4>Tutorial interactivo</h4>
<p>Listar pods</p>
<pre class="code literal-block"><span></span><code><span class="err">kubectl get pods</span>
</code></pre>


<p>Para obtener información detallada de los Pods</p>
<pre class="code literal-block"><span></span><code><span class="err">kubectl describe pods</span>
</code></pre>


<p>Para acceder a los Pods, que funcionan en una red aislada y privada, se utiliza
el <code>proxy</code>:</p>
<pre class="code literal-block"><span></span><code><span class="err">kubectl proxy</span>
</code></pre>


<p>Dicho proxy expone temporalmente la red y permite la comunicación con el host.
Esto se utiliza para acceder a la API de los Pods y realizar consultas de forma
directa (Por ejemplo, usando el comando <code>curl</code>).</p>
<p>Para diversas operaciones con los pods, es necesario obtener el nombre que
Kubernetes le asigno al mismo. Un comando para hacer esto es:</p>
<pre class="code literal-block"><span></span><code><span class="x">export POD_NAME=$(kubectl get pods -o go-template --template '</span><span class="cp">{{</span><span class="nv">range</span> <span class="nv">.items</span><span class="cp">}}{{</span><span class="nv">.metadata.name</span><span class="cp">}}{{</span><span class="s2">"\n"</span><span class="cp">}}{{</span><span class="nv">end</span><span class="cp">}}</span><span class="x">')</span>
</code></pre>


<p>Para ver los logs:</p>
<pre class="code literal-block"><span></span><code><span class="err">kubectl logs $POD_NAME</span>
</code></pre>


<p>Todo lo que los proceso envien a stdout es expuesto como logs del pod.</p>
<p>Ejecutar comandos en un pod:</p>
<pre class="code literal-block"><span></span><code><span class="err">kubectl exec $POD_NAME env</span>
</code></pre>


<p>Abrir una consola en un POD:</p>
<pre class="code literal-block"><span></span><code><span class="err">kubectl exec -ti $POD_NAME bash</span>
</code></pre>


<h3>4. Usar un servicio para exponer la App</h3>
<p>Los Pods pueden ser reemplazados si es necesario. Desde que cada Pod tiene una
IP unica, las aplicaciones no deberian conocer dichas IPs para poder conectarse
a los Pods, porque estos puede "morir".</p>
<p>Los servicios en kubernetes proveen una abstraccion que permite establecer
politicas de acceso sobre un conjunto lógico de Pods.</p>
<p>Los servicios permiten que a los pods se les adjunten labels, con diferentes
objetivos (taggear versiones, separar versiones para test, debug y produccion).</p>
<h4>Tutorial interactivo</h4>
<p>Listar servicios expuestos:</p>
<pre class="code literal-block"><span></span><code><span class="err">kubectl get services</span>
</code></pre>


<p>Exponer un servicio:</p>
<pre class="code literal-block"><span></span><code><span class="err">kubectl expose deployment/kubernetes-bootcamp --type="NodePort" --port 8080</span>
</code></pre>


<p>Ver detalles de servicios:</p>
<pre class="code literal-block"><span></span><code><span class="err">kubectl describe services/kubernetes-bootcamp</span>
</code></pre>


<p>Ver que puerto fue abierto externamente:</p>
<pre class="code literal-block"><span></span><code><span class="x">export NODE_PORT=$(kubectl get services/kubernetes-bootcamp -o go-template='</span><span class="cp">{{</span><span class="o">(</span><span class="nv">index</span> <span class="nv">.spec.ports</span> <span class="m">0</span><span class="o">)</span><span class="nv">.nodePort</span><span class="cp">}}</span><span class="x">')</span>
<span class="x">echo NODE_PORT=$NODE_PORT</span>
</code></pre>


<p>Una vez expuesto, se puede consultar el servicio directamente con:</p>
<pre class="code literal-block"><span></span><code><span class="err">curl host01:$NODE_PORT</span>
</code></pre>


<p>Consultar los pods que estan etiquetados con un label particular:</p>
<pre class="code literal-block"><span></span><code><span class="err">kubectl get pods -l run=kubernetes-bootcamp</span>
</code></pre>


<p>El label en el caso anterior es <code>run=kubernetes-bootcamp</code>. Funciona
identicamente para consultar servicios:</p>
<pre class="code literal-block"><span></span><code><span class="err">kubectl get services -l run=kubernetes-bootcamp</span>
</code></pre>


<p>Obtener el nombre del POD</p>
<pre class="code literal-block"><span></span><code><span class="x">export POD_NAME=$(kubectl get pods -o go-template --template '</span><span class="cp">{{</span><span class="nv">range</span> <span class="nv">.items</span><span class="cp">}}{{</span><span class="nv">.metadata.name</span><span class="cp">}}{{</span><span class="s2">"\n"</span><span class="cp">}}{{</span><span class="nv">end</span><span class="cp">}}</span><span class="x">')</span>
<span class="x">echo Name of the Pod: $POD_NAME</span>
</code></pre>


<p>Aplicar un nuevo label a un Pod:</p>
<pre class="code literal-block"><span></span><code><span class="err">kubectl label pod $POD_NAME app=v1</span>
</code></pre>


<p>Consultar el label recien aplicado:</p>
<pre class="code literal-block"><span></span><code><span class="err">kubectl describe pods $POD_NAME</span>
<span class="err">kubectl get pods -l app=v1</span>
</code></pre>


<p>Borrar un servicio:</p>
<pre class="code literal-block"><span></span><code><span class="err">kubectl delete service -l run=kubernetes-bootcamp</span>
</code></pre>


<h3>5. Multiples instancias de una App</h3>
<p>Escalar es incrementar el numero de instancias o pods para poder manejar
incrementos de trafico en la aplicación. Los services manejan el trafico hacia
los pods mendiante un load-balancer.</p>
<h4>Tutorial interactivo</h4>
<p>Escalar (scale up) un deployment llamado kubernetes-bootcamp a 4 replicas:</p>
<pre class="code literal-block"><span></span><code><span class="err">kubectl scale deployments/kubernetes-bootcamp --replicas=4</span>
</code></pre>


<p>Ver los deployments:</p>
<pre class="code literal-block"><span></span><code><span class="err">kubectl get deployments</span>
</code></pre>


<p>Controlar los pods (Tiene que haber 4):</p>
<pre class="code literal-block"><span></span><code><span class="err">kubectl get pods -o wide</span>
</code></pre>


<p>Ver el deployment de forma mas detallada:</p>
<pre class="code literal-block"><span></span><code><span class="err">kubectl describe deployments/kubernetes-bootcamp</span>
</code></pre>


<p>Ver el servicio:</p>
<pre class="code literal-block"><span></span><code><span class="err">kubectl describe services/kubernetes-bootcamp</span>
</code></pre>


<p>Recuperar el nodo:</p>
<pre class="code literal-block"><span></span><code><span class="x">export NODE_PORT=$(kubectl get services/kubernetes-bootcamp -o go-template='</span><span class="cp">{{</span><span class="o">(</span><span class="nv">index</span> <span class="nv">.spec.ports</span> <span class="m">0</span><span class="o">)</span><span class="nv">.nodePort</span><span class="cp">}}</span><span class="x">')</span>
<span class="x">echo NODE_PORT=$NODE_PORT</span>
</code></pre>


<p>Ejecutar varias veces:</p>
<pre class="code literal-block"><span></span><code><span class="err">curl host01:$NODE_PORT</span>
</code></pre>


<p>Deberian responder diferentes pods de la misma app.</p>
<p>Ejecutar ahora solo 2 replicas (Scale down):</p>
<pre class="code literal-block"><span></span><code><span class="err">kubectl scale deployments/kubernetes-bootcamp --replicas=2</span>
</code></pre>


<p>Confirmar el cambio:</p>
<pre class="code literal-block"><span></span><code><span class="err">kubectl get deployments</span>
</code></pre>


<h3>6. Realizando actualizaciones progresivas</h3>
<p>La idea es lograr actualizaciones sin que se experimente una caida del servicio,
esto permite poder actualizar las aplicaciones de forma mas seguida.</p>
<p>Kubernetes permite esto mediante las Rolling Updates. Esto permite actualizar
sin tener downtimes y ademas puede ser revertido en caso de problemas
(rollbacks).</p>
<h4>Tutorial interactivo</h4>
<p>Ver imagen actual de los pods (Campo image):</p>
<pre class="code literal-block"><span></span><code><span class="err">kubectl describe pods</span>
</code></pre>


<p>Actualizar la image:</p>
<pre class="code literal-block"><span></span><code><span class="err">kubectl set image deployments/kubernetes-bootcamp kubernetes-bootcamp=jocatalin/kubernetes-bootcamp:v2</span>
</code></pre>


<p>Ver información de los Pods:</p>
<pre class="code literal-block"><span></span><code><span class="err">kubectl get pods</span>
</code></pre>


<p>No actualiza los viejos pods, sino que termina los anteirores y crea pods
nuevos.</p>
<p>Verificar que la app actualizo:</p>
<pre class="code literal-block"><span></span><code><span class="x">kubectl describe services/kubernetes-bootcamp</span>
<span class="x">export NODE_PORT=$(kubectl get services/kubernetes-bootcamp -o go-template='</span><span class="cp">{{</span><span class="o">(</span><span class="nv">index</span> <span class="nv">.spec.ports</span> <span class="m">0</span><span class="o">)</span><span class="nv">.nodePort</span><span class="cp">}}</span><span class="x">')</span>
<span class="x">echo NODE_PORT=$NODE_PORT</span>
<span class="x">curl host01:$NODE_PORT</span>
</code></pre>


<p>Tambien puede verificarse el exito mediante:</p>
<pre class="code literal-block"><span></span><code><span class="err">kubectl rollout status deployments/kubernetes-bootcamp</span>
</code></pre>


<p>Deployar una version "con errores":</p>
<pre class="code literal-block"><span></span><code><span class="err">kubectl set image deployments/kubernetes-bootcamp kubernetes-bootcamp=jocatalin/kubernetes-bootcamp:v10</span>
</code></pre>


<p>Ver problemas:</p>
<pre class="code literal-block"><span></span><code><span class="err">kubectl get deployments</span>
<span class="err">kubectl get pods</span>
<span class="err">kubectl describe pods</span>
</code></pre>


<p>Rollback:</p>
<pre class="code literal-block"><span></span><code><span class="err">kubectl rollout undo deployments/kubernetes-bootcamp</span>
<span class="err">kubectl get pods</span>
<span class="err">kubectl describe pods</span>
</code></pre>


<h2>Dudas</h2>
<ul>
<li>¿Un cluster kubernetes sirve para deploy de una app unica o muchas apps
 pueden convivir en el?</li>
</ul>
<p>Se pueden hacer deploys de varias apps y se iran acomodando en los recursos que
el cluster tenga disponibles.</p>
<ul>
<li>¿Un Pod es equivalente a un container?</li>
</ul>
<p>Un pod es un container de una aplicación en particular gestionado por kubernetes</p>
<h2>Troubleshooting</h2>
<ul>
<li>Al querer ejecutar <code>minikube start</code> se obtiene el error "Error starting host: Error getting state for host: machine does not exist".</li>
</ul>
<p>El error completo es:</p>
<pre class="code literal-block"><span></span><code>$ minikube start
Starting <span class="nb">local</span> Kubernetes v1.9.0 cluster...
Starting VM...
E0428 <span class="m">17</span>:06:43.557255   <span class="m">18070</span> start.go:159<span class="o">]</span> Error starting host: Error getting state <span class="k">for</span> host: machine does not exist.

 Retrying.
E0428 <span class="m">17</span>:06:43.557517   <span class="m">18070</span> start.go:165<span class="o">]</span> Error starting host:  Error getting state <span class="k">for</span> host: machine does not <span class="nv">exist</span>
<span class="o">================================================================================</span>
An error has occurred. Would you like to opt in to sending anonymized crash
information to minikube to <span class="nb">help</span> prevent future errors?
To opt out of these messages, run the command:
        minikube config <span class="nb">set</span> WantReportErrorPrompt <span class="nb">false</span>
<span class="o">================================================================================</span>
Please enter your response <span class="o">[</span>Y/n<span class="o">]</span>: n
</code></pre>


<p>Esto me pasó a mi por borrar en algun momento la vm de Virtualbox que crea minikube. La forma mas facil de recuperarse de este error es:</p>
<pre class="code literal-block"><span></span><code>$ minikube delete
$ minikube start
</code></pre>
</div>
        </div>
    </article><script>var disqus_shortname="tomasdel";(function(){var a=document.createElement("script");a.async=true;a.src="https://"+disqus_shortname+".disqus.com/count.js";(document.getElementsByTagName("head")[0]||document.getElementsByTagName("body")[0]).appendChild(a)}());</script><footer id="footer"><p><a href="mailto:tdelvechio@unlu.edu.ar">Tomás Delvechio</a> - Powered by         <a href="https://getnikola.com" rel="nofollow">Nikola</a>         
<a rel="license" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">
<img alt="Creative Commons License BY-NC-SA" style="border-width:0; margin-bottom:12px;" src="https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png"></a>. Ultima actualización: Enero 2018.</p>
            
        </footer>
</div>
    </section><script src="../assets/js/all.js"></script><script>
    baguetteBox.run('div#content', {
        ignoreClass: 'islink',
        captions: function(element) {
            return element.getElementsByTagName('img')[0].alt;
    }});
    </script><!-- Global site tag (gtag.js) - Google Analytics --><script async src="https://www.googletagmanager.com/gtag/js?id=UA-16017127-6"></script><script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-16017127-6');
</script>
</body>
</html>
